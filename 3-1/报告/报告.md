# lab3-1 计算机网络
>冯杰康 1813402 计算机科学与技术专业
## 协议设计 

### 差错检测
   使用checksum进行差错检测，类似于udp的差错检测方式，使用回卷加法，之后将加和进行反码运算，放在数据的最开头，并且回卷加法使用8比特加法。
   <img src="./1.png" height=15>
   在发送方的检测使用时，差错和使用0，接收方接收到的数据进行整体的差错检测(包括差错和和数据报文)，如果没有差错，那么接收方的回卷加法和将是0。

   差错和存放的数据为回卷加法的反码。

   同样的，对于ACK/NAK包也需要进行差错检测。
   <img src="./2.png" height=15>

### 数据内容说明
   <img src="./1.png" height=15>

   其中数据表文表示如下。

   <img src="./3.png" height=15>

   标志位为1字节（8比特）；序号位1字节（8比特）表示数据包的序号，并且ACK/NAK也会包含标志位和序号位；之后的数据全部为信息数据。

   对于整个发送的整条信息的最后一个段来说，如果是最后一个报文段，我们需要一个字节来表示他的数据段长度：
   <img src="./4.png" height=15>
   
   如图所示，长度位位一个字节（8比特），表示后面的数据包的长度，因此如果最后一个数据包长度为509字节时，整个报文的长度可能达到513字节，因此再接受的时候需要统一按照513字节接收。
   
### 连接建立
   建立连接的时候使用3次握手，并且和TCP有些许不同。
   - 第一次的客户端向服务器发送握手协议标志位最低位为1（一个字节内的最低位为从右到左第一位），标志位其他的位为0，并且没有序号位和数据位，之后计算差错和，发送给服务器；
  
   - 服务器接收到后返回一个数据包，标志位倒数第二位的1，其他位为0，没有序号位和数据，之后计算差错和，返回给客户端；
   - 客户端收到这个数据包之后发送一个标志位倒数第三位为1，其他位为0的数据包，表示连接建立完成，此时两台机器可以开始进行可靠数据传输。

   链接建立阶段发送得3个数据包长度均为2字节（为差错检测位和标志位）。   

### 数据包的长度限制

对于一个数据包的长度是有限制的，对于不是整个传输数据结尾的数据包来说最多数据长度为509个字节，即数据报文为512个字节（加上标志位和序号位）。对于传输段最后的不完整的数据来说则有多少发多少。
对于非结尾数据包，标志位的倒数第4位为1；对于结尾数据包，标志位的倒数4，5位为1；

>因为一整个链接期间，可能发送得整个数据段不止一个，因此序号位需要在整个链接未断开时不断递增，否则接收方可能会混淆不同的阶段的数据。

### ACK / NAK 数据包

服务器接收到数据包之后，对于数据进行差错检测，对于"差错和"和"数据报文"进行统一的校验操作，ACK和NAK数据包长度均为3字节（包含差错检测位，标志位和序号位，序号位为其对应的接收包的序号，NAK序号可能不准确）。

- 如果回卷加法的结果是0，那么证明没有错误产生，则缓存接收到的数据报文。之后向客户端发送ACK数据包，ACK数据包的标志位的后两位为1，其他位都为0；
- 如果回卷加法的结果不是0，那么证明出错了，那么发送NAK数据包，NAK数据包的标志位后3位为1，其他位都为0，表示接受的数据包出错。

### 超时重传 / 出错重传
   因为停等机制的存在，我们需要在设置适当的停止等待协议，在数据包丢包的时候就会进行超时重传；并且在ACK/NAK进行丢包的时候也能进行数据包的超时重传。
   
   - 超时重传：对于当前数据包开启一个计时器，如果超时则进行重传，并且选择适当的序号位。
   - 出错重传：出错重传分为两种，一个是自己的数据包重传，当对方发来的的NAK数据包被接收到的时候，我们需要进行重传；第二个是接收到的ACK或者NAK数据包校验有问题，无法恢复，则进行重传之前的数据包。
   
   为了和之前保持一致，重传数据包的的标志位也和之前的标志位相同。

### 连接断开
   断开连接使用两次挥手协议，首先断开数据包由客户端发送。
   - 客户端发送一个标志位第一位为1的数据包，之后开始回收和释放自己的资源。
   - 服务端接受到一个标志位第一位的1的数据包之后，也开始释放自己的资源，之后向客户端发送一个标志位第2位为1的数据包，断开连接。

   客户端需要接收到服务端的连接之后才能完全关闭连接，否则进行重传，链接断开的两个数据包长度均为2字节（包含差错检测位和标志位）。

### 握手和挥手过程中的错误和丢包

如果在挥手和握手期间传递的数据包出错，则从头进行整个挥手握手过程，保证连接信息完整性。


## 功能实现

程序使用了两份代码进行实现，一份为客户端代码，为发送方，一份为服务端代码，为接收方。

程序会让发送方输入服务器的ip地址和所要发送的文件的文件名，之后程序进行连接和处理。
首先我们会将文件名作为一个单独的数据段发送过去，之后发送整个文件的数据段，在接收端接收到两端数据之后，就可以根据文件名进行数据解析工作，或者在本地存储数据。

#### 实现细节

在文件传输过程中的超时的设置：
>因为在服务端recvfrom是进行阻塞接受的，我们先使用库函数将其阻塞时间进行设置，在我们的TIMEOUT范围之内。


传输的关键位置的丢包问题：
>握手挥手过程中的丢包因为无法确认和检测，只能进行重新进行握手挥手实现，并且在挥手中进行超时次数的设置，超过次数认为对方完全断网，自己则进行资源回收后断网。
传输第一个数据段的最后一个包的重传，可能会让接收方误认为是第二段的结束，我们需要设置全程传输时的序号递增，这样就可以解决上述问题
